<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>memcpy.io - graphics</title><link href="https://memcpy.io/" rel="alternate"></link><link href="https://memcpy.io/feeds/graphics.atom.xml" rel="self"></link><id>https://memcpy.io/</id><updated>2020-01-15T00:00:00+01:00</updated><entry><title>Panfrost: Liberating ARM GPUs @ Linux Conf Au</title><link href="https://memcpy.io/panfrost-liberating-arm-gpus-linux-conf-au.html" rel="alternate"></link><published>2020-01-15T00:00:00+01:00</published><updated>2020-01-15T00:00:00+01:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2020-01-15:/panfrost-liberating-arm-gpus-linux-conf-au.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/files/2020-01-15/title.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2020-01-15/2020_lca_panfrost_robertfoss.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2020-01-15/2020_lca_panfrost_robertfoss.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Diagrams&lt;/h2&gt;
&lt;h4&gt;Overview&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_overview.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_overview.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Kernel&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_kernel_1.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_kernel_1.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_kernel_2.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_kernel_2.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Userspace&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_userspace_1.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_userspace_1.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_userspace_2.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_userspace_2.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_userspace_3.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_userspace_3.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Mesa overview&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_mesa_overview.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_overview.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Mesa Gallium&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_mesa_gallium_1.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_gallium_1.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_mesa_gallium_2.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_gallium_2.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Mesa Winsys&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_mesa_winsys_1.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_winsys_1.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_mesa_winsys_2.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_winsys_2.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h4&gt;Mesa Compiler&lt;/h4&gt;
&lt;p&gt;&lt;a href="/files/2020-01-15/diagram_mesa_compiler_1.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_compiler_1.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_mesa_compiler_2.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_compiler_2.svg"&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href="/files/2020-01-15/diagram_mesa_compiler_3.svg"&gt;&lt;img alt="" src="/files/2020-01-15/diagram_mesa_compiler_3.svg"&gt;&lt;/a&gt;  &lt;/p&gt;
&lt;h2&gt;License&lt;/h2&gt;
&lt;p&gt;All of the material you can find on this page is licensed under the
&lt;a href="https://opensource.org/licenses/MIT"&gt;MIT&lt;/a&gt; license, and you are free to use,
modify and re-distribute these materials however you like.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://linux.conf.au/"&gt;Linux Conf Au&lt;/a&gt; for hosting the event.
This was my first LCA, and I think it may be the best Linux conference out of all of them.&lt;/p&gt;
&lt;p&gt;I would also like to thank the organizers for paying for my flights,
without it I would not have been able to give this talk.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="linux"></category><category term="conf"></category><category term="au"></category><category term="lca"></category><category term="graphics"></category><category term="open source"></category><category term="drivers"></category></entry><entry><title>Panfrost the Open Source Arm GPU Driver @ ELC NA</title><link href="https://memcpy.io/panfrost-the-open-source-arm-gpu-driver-elc-na.html" rel="alternate"></link><published>2019-09-22T00:00:00+02:00</published><updated>2019-09-22T00:00:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-09-22:/panfrost-the-open-source-arm-gpu-driver-elc-na.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2019-08-22_panfrost_gpu_driver_elc_na.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2019-08-22/2019_panfrost_elc-na.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2019-08-22/2019_panfrost_elc-na.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://events.linuxfoundation.org/events/elc-north-america-2019/"&gt;ELC NA&lt;/a&gt; for hosting the event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="embedded"></category><category term="linux"></category><category term="elc"></category><category term="graphics"></category><category term="open source"></category><category term="drivers"></category></entry><entry><title>Status of the Embedded GPU Space @ ELC NA</title><link href="https://memcpy.io/status-of-the-embedded-gpu-space-elc-na.html" rel="alternate"></link><published>2019-09-21T00:00:00+02:00</published><updated>2019-09-21T00:00:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-09-21:/status-of-the-embedded-gpu-space-elc-na.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2019-08-21_embedded_gpu_elc_na.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2019-08-21/2019_embedded-gfx_embedded-world.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2019-08-21/2019_embedded-gfx_embedded-world.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://events.linuxfoundation.org/events/elc-north-america-2019/"&gt;ELC NA&lt;/a&gt; for hosting the event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="embedded"></category><category term="linux"></category><category term="elc"></category><category term="graphics"></category><category term="open source"></category><category term="drivers"></category></entry><entry><title>Running Android and Wayland on Embedded Devices</title><link href="https://memcpy.io/running-android-and-wayland-on-embedded-devices.html" rel="alternate"></link><published>2019-05-03T10:39:00+02:00</published><updated>2019-05-03T10:39:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-05-03:/running-android-and-wayland-on-embedded-devices.html</id><summary type="html">&lt;p&gt;&lt;a href="/running-android-next-to-wayland.html"&gt;A previous post&lt;/a&gt; introduced the &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/"&gt;SPURV&lt;/a&gt;
Android compatibility layer for Wayland based Linux environment.&lt;br&gt;
In this post we're going to dig into how you can run an Android application
on the very common i.MX6 based &lt;a href="https://boundarydevices.com/product/nitrogen6max/"&gt;Nitrogen6_MAX&lt;/a&gt;
board from &lt;a href="https://boundarydevices.com/"&gt;Boundary Devices&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Install dependencies&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;sudo apt install \&lt;/span&gt;
&lt;span class="err"&gt;    apt-transport-https \&lt;/span&gt;
&lt;span class="err"&gt;    bmap-tools \&lt;/span&gt;
&lt;span class="err"&gt;    ca-certificates \&lt;/span&gt;
&lt;span class="err"&gt;    curl \&lt;/span&gt;
&lt;span class="err"&gt;    git \&lt;/span&gt;
&lt;span class="err"&gt;    gnupg2 \&lt;/span&gt;
&lt;span class="err"&gt;    repo \&lt;/span&gt;
&lt;span class="err"&gt;    software-properties-common \&lt;/span&gt;
&lt;span class="err"&gt;    u-boot-tools \&lt;/span&gt;
&lt;span class="err"&gt;    qemu-kvm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Set up Docker container for building&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Install Docker
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable&amp;quot;
sudo apt update
sudo apt install docker-ce

# Set up privileges for Docker
sudo usermod -aG docker &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;USER&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
su - &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;USER&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;

# Fetch Docker image
docker pull godebos/debos:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Build&lt;/h2&gt;
&lt;h3&gt;Build Android&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;mkdir android; cd android&lt;/span&gt;
&lt;span class="err"&gt;repo …&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/running-android-next-to-wayland.html"&gt;A previous post&lt;/a&gt; introduced the &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/"&gt;SPURV&lt;/a&gt;
Android compatibility layer for Wayland based Linux environment.&lt;br&gt;
In this post we're going to dig into how you can run an Android application
on the very common i.MX6 based &lt;a href="https://boundarydevices.com/product/nitrogen6max/"&gt;Nitrogen6_MAX&lt;/a&gt;
board from &lt;a href="https://boundarydevices.com/"&gt;Boundary Devices&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Install dependencies&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;sudo apt install \&lt;/span&gt;
&lt;span class="err"&gt;    apt-transport-https \&lt;/span&gt;
&lt;span class="err"&gt;    bmap-tools \&lt;/span&gt;
&lt;span class="err"&gt;    ca-certificates \&lt;/span&gt;
&lt;span class="err"&gt;    curl \&lt;/span&gt;
&lt;span class="err"&gt;    git \&lt;/span&gt;
&lt;span class="err"&gt;    gnupg2 \&lt;/span&gt;
&lt;span class="err"&gt;    repo \&lt;/span&gt;
&lt;span class="err"&gt;    software-properties-common \&lt;/span&gt;
&lt;span class="err"&gt;    u-boot-tools \&lt;/span&gt;
&lt;span class="err"&gt;    qemu-kvm&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Set up Docker container for building&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;# Install Docker
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo apt-key add -
sudo add-apt-repository &amp;quot;deb [arch=amd64] https://download.docker.com/linux/debian $(lsb_release -cs) stable&amp;quot;
sudo apt update
sudo apt install docker-ce

# Set up privileges for Docker
sudo usermod -aG docker &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;USER&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
su - &lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;USER&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;

# Fetch Docker image
docker pull godebos/debos:latest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2&gt;Build&lt;/h2&gt;
&lt;h3&gt;Build Android&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;mkdir android; cd android&lt;/span&gt;
&lt;span class="err"&gt;repo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r10&lt;/span&gt;
&lt;span class="err"&gt;git clone https://gitlab.collabora.com/spurv/android_manifest.git .repo/local_manifests/&lt;/span&gt;
&lt;span class="err"&gt;repo sync -j15&lt;/span&gt;
&lt;span class="err"&gt;. build/envsetup.sh&lt;/span&gt;
&lt;span class="err"&gt;lunch spurv-eng&lt;/span&gt;
&lt;span class="err"&gt;make -j12&lt;/span&gt;
&lt;span class="err"&gt;cd ..&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Build Linux Kernel&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;git clone https://gitlab.collabora.com/spurv/linux.git -b android-container_v5.1-rc5&lt;/span&gt;
&lt;span class="err"&gt;cd linux&lt;/span&gt;
&lt;span class="err"&gt;sh ../android/device/freedesktop/spurv/build-kernel.sh&lt;/span&gt;
&lt;span class="err"&gt;cd ..&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3&gt;Create root filesystem&lt;/h3&gt;
&lt;p&gt;Just a kernel does not make an OS, so we're using Debian as a base.&lt;br&gt;
The way we're going to create the root filesystem is using &lt;a href="https://github.com/go-debos/debos"&gt;debos&lt;/a&gt;,
which is a tool for creating Debian based OS images.&lt;/p&gt;
&lt;h3&gt;Create &amp;amp; flash image&lt;/h3&gt;
&lt;p&gt;Now we're ready to integrate all of the above into one coherent image.
This is where the Nitrogen6_MAX devboard targeting comes in.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;git clone https://gitlab.collabora.com/spurv/debos.git&lt;/span&gt;
&lt;span class="err"&gt;sudo debos/build_image.sh -b /dev/mmcblk0&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;The platform specific parts are contained in &lt;a href="https://gitlab.collabora.com/spurv/debos/blob/master/uboot_nitrogen6qp-max.scr"&gt;uboot_nitrogen6qp-max.scr&lt;/a&gt;
and &lt;a href="https://gitlab.collabora.com/spurv/debos/blob/master/build_image.sh"&gt;build_image.sh&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Boot!&lt;/h2&gt;
&lt;p&gt;Pop the flashed SD-card into your device and restart it, and then log in as
&lt;code&gt;root/root&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In order to start Android, run one of these two commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;code&gt;&lt;span class="err"&gt;# Launch just and Android application&lt;/span&gt;
&lt;span class="err"&gt;/home/aosp/run.sh&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Starting the Android application might take a minute or two, but Weston should
start immediately.&lt;/p&gt;
&lt;h2&gt;Acknowledgments&lt;/h2&gt;
&lt;p&gt;A lot of different contributors enabled this work, both directly and indirectly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boundary Devices&lt;/li&gt;
&lt;li&gt;Pengutronix&lt;/li&gt;
&lt;li&gt;Zodiac&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="android"></category><category term="linux"></category><category term="open source"></category><category term="graphics"></category><category term="wayland"></category><category term="android"></category><category term="3d"></category><category term="acceleration"></category><category term="imx6"></category><category term="nitrogen6"></category></entry><entry><title>Running Android next to Wayland</title><link href="https://memcpy.io/running-android-next-to-wayland.html" rel="alternate"></link><published>2019-04-01T18:07:00+02:00</published><updated>2019-04-01T18:07:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-04-01:/running-android-next-to-wayland.html</id><summary type="html">&lt;p&gt;Running Android has some advantages compared to native Linux applications,
for example with regard to the availability of applications and application
developers.&lt;/p&gt;
&lt;p&gt;For current non-Android systems, this work enables a path forward to running
Android applications in the same graphical environment as traditional non-Android
applications are run.&lt;/p&gt;
&lt;div style#"text-align:center;"&gt;
&lt;iframe width="830" height="460" src="https://www.youtube.com/embed/594fIHWQSj4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2&gt;What is SPURV?&lt;/h2&gt;
&lt;p&gt;SPURV is our experimental containerized Android environment, and
this is a quick overview of what it is.&lt;/p&gt;
&lt;p&gt;It's aptly named after the &lt;a href="https://en.wikipedia.org/wiki/SPURV"&gt;first robotic fish&lt;/a&gt;
since a common Android naming scheme is fish-themed names. Much like its spiritual
ancestor Goldfish, the Android emulator.&lt;/p&gt;
&lt;h3&gt;Other Android Compatibility Layers&lt;/h3&gt;
&lt;p&gt;This means that Anbox which is LXC based, is different from SPURV in terms of
how hardware is accessed. The hardware access that Anbox provides in indirect,
and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Running Android has some advantages compared to native Linux applications,
for example with regard to the availability of applications and application
developers.&lt;/p&gt;
&lt;p&gt;For current non-Android systems, this work enables a path forward to running
Android applications in the same graphical environment as traditional non-Android
applications are run.&lt;/p&gt;
&lt;div style#"text-align:center;"&gt;
&lt;iframe width="830" height="460" src="https://www.youtube.com/embed/594fIHWQSj4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2&gt;What is SPURV?&lt;/h2&gt;
&lt;p&gt;SPURV is our experimental containerized Android environment, and
this is a quick overview of what it is.&lt;/p&gt;
&lt;p&gt;It's aptly named after the &lt;a href="https://en.wikipedia.org/wiki/SPURV"&gt;first robotic fish&lt;/a&gt;
since a common Android naming scheme is fish-themed names. Much like its spiritual
ancestor Goldfish, the Android emulator.&lt;/p&gt;
&lt;h3&gt;Other Android Compatibility Layers&lt;/h3&gt;
&lt;p&gt;This means that Anbox which is LXC based, is different from SPURV in terms of
how hardware is accessed. The hardware access that Anbox provides in indirect,
and through the Qemu Pipes functionality, which is something it adopted from
the Android (goldfish) emulator.&lt;/p&gt;
&lt;p&gt;Shashlik and Genimobile are Android on Linux integration layers both based on
Qemu, which means even better security properties than Anbox and certainly SPURV,
but at the cost of an even larger performance penalty.&lt;/p&gt;
&lt;h3&gt;Direct Hardware Access&lt;/h3&gt;
&lt;p&gt;SPURV is different from other Linux desktop integrations for Android
since it offers direct hardware access to the Android application.
This is a choice we made for performance reasons. But has drawbacks, especially
when it comes to security.&lt;br&gt;
Using direct hardware access does however grant us increased GPU and CPU
performance, which is important since we're targeting embedded platforms
which can have very limited resources.&lt;/p&gt;
&lt;h2&gt;Components&lt;/h2&gt;
&lt;p&gt;SPURV consists of a few different parts, all living in the same &lt;a href="https://gitlab.collabora.com/spurv/"&gt;project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="An overview of the SPURV stack" src="/images/2019_spurv.svg"&gt;&lt;/p&gt;
&lt;h3&gt;Android target device&lt;/h3&gt;
&lt;p&gt;This component integrates SPURV into Android, and it does so by using the
&lt;code&gt;device&lt;/code&gt; infrastructure that the Android codebase provides.&lt;/p&gt;
&lt;p&gt;Devices are normally used to customize an Android build to the
specific needs of a given hardware platform, like a new smartphone
SOC. In the case of SPURV, we're targeting being run inside of
a &lt;code&gt;systemd-nspawn&lt;/code&gt; container.&lt;/p&gt;
&lt;h3&gt;SPURV Audio&lt;/h3&gt;
&lt;p&gt;This component bridges the Android Audio Hardware Abtraction Layer (HAL) to
the host PulseAudio stack.&lt;/p&gt;
&lt;h3&gt;SPURV HWComposer&lt;/h3&gt;
&lt;p&gt;Integrates Android windows into Wayland. It does so by implementing a HWC-to-Wayland bridge.&lt;/p&gt;
&lt;p&gt;HWC is the Android API for implementing display &amp;amp; buffer management, and what it essentially
does in interpret all of the different display buffers that Android applications produce,
and organizes them into one cohesive Desktop.&lt;/p&gt;
&lt;p&gt;This protocol is conceptually not unlike the Wayland protocol, which allows for the HWC to
be translated into Wayland. This is essentially what the SPURV HWComposer does.&lt;/p&gt;
&lt;p&gt;Additionally it deals with input, like touch screen events and passes them along from Wayland
to Android, this however is unrelated to the HWC API.&lt;/p&gt;
&lt;h3&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;The SPURV Android target device behaves as a faux Android device, and tailors
the Android build to our requirements.&lt;/p&gt;
&lt;p&gt;Functions SPURV performs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customizes defaults.&lt;/li&gt;
&lt;li&gt;Configures network.&lt;/li&gt;
&lt;li&gt;Enables an audio bridge from Android to PulseAudio.&lt;/li&gt;
&lt;li&gt;Enables a graphics bridge from Android to Wayland.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;How can I use it?&lt;/h2&gt;
&lt;p&gt;Full build instructions as can be found on our &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/README.md"&gt;GitLab&lt;/a&gt; for the &lt;a href="https://gitlab.collabora.com/spurv"&gt;SPURV project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An overview of setting up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fetch Android (AOSP) and the Linux kernel,&lt;/li&gt;
&lt;li&gt;Integrate SPURV into Android,&lt;/li&gt;
&lt;li&gt;Build Android &amp;amp; Linux Kernel,&lt;/li&gt;
&lt;li&gt;Build a debootstrap based root filesystem, and&lt;/li&gt;
&lt;li&gt;Flash Kernel, Android and root filesystem to the device of your choice.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What comes next?&lt;/h2&gt;
&lt;p&gt;The next few steps will be adding support for more hardware platforms
in our build scripts, but also optimizing the experience.&lt;/p&gt;
&lt;p&gt;In no particular order, this is what we would like to look at next:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bring-up on the i.MX8M with the etnaviv graphics driver.&lt;/li&gt;
&lt;li&gt;Slimming things down so it takes less time to start an app and consumes less
   RAM for the case where the goal is to just to run a single app.&lt;/li&gt;
&lt;li&gt;Bring-up on x86 with Ubuntu, publishing runtime binaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Caveats&lt;/h2&gt;
&lt;p&gt;The way SPURV is implemented means that a full OS is being run in a container,
which has implications both positive and negative.&lt;/p&gt;
&lt;p&gt;One of the positive effects is increased isolation of Android applications,
which means improved security and privacy for potentially untrusted applications.&lt;/p&gt;
&lt;p&gt;Additionally, this approach allows for Android applications to be run next to
Wayland based applications in a desktop environment.&lt;/p&gt;
&lt;p&gt;The downsides relate to hardware access and performance. All hardware access
that is needed by Android has to be passed into the container.
Besides manually having to configure such access using &lt;code&gt;systemd-nspawn&lt;/code&gt;,
there are also performance costs associated with running a container.
One part of this is the static cost of having to load an entire OS on top
of the base OS, but there are also additional runtime performance penalties
for applications in the container.&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Pengutronix&lt;/li&gt;
&lt;li&gt;Zodiac&lt;/li&gt;
&lt;li&gt;Boundary Devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="android"></category><category term="linux"></category><category term="open source"></category><category term="graphics"></category><category term="wayland"></category><category term="android"></category><category term="3d"></category><category term="acceleration"></category></entry><entry><title>Status of the Embedded GPU Space @ Embedded World</title><link href="https://memcpy.io/status-of-the-embedded-gpu-space-embedded-world.html" rel="alternate"></link><published>2019-02-27T00:00:00+01:00</published><updated>2019-02-27T00:00:00+01:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-02-27:/status-of-the-embedded-gpu-space-embedded-world.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2019-02-27_embedded_world.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.odp"&gt;ODP&lt;/a&gt; and of course the &lt;a href="files/2019-02-27/2019_embedded-world_embedded-gpu-space.pdf"&gt;whitepaper&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://www.embedded-world.de/en"&gt;Embedded World&lt;/a&gt; for hosting a great event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="embedded"></category><category term="world"></category><category term="graphics"></category><category term="open source"></category><category term="drivers"></category><category term="linux"></category></entry><entry><title>Android on Mainline Graphics @ All Systems Go</title><link href="https://memcpy.io/android-on-mainline-graphics-all-systems-go.html" rel="alternate"></link><published>2018-09-29T00:00:00+02:00</published><updated>2018-09-29T00:00:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2018-09-29:/android-on-mainline-graphics-all-systems-go.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2018-09-29_all_systems_go.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2018-09-29/2018_running_android_on_mainline_gfx_all_systems_go.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2018-09-29/2018_running_android_on_mainline_gfx_all_systems_go.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://all-systems-go.io/"&gt;All Systems Go!&lt;/a&gt;, the &lt;a href="https://twitter.com/ASGConf"&gt;@ASGConf&lt;/a&gt; for hosting a great event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="all systems go"></category><category term="linux"></category><category term="graphics"></category><category term="drivers"></category></entry><entry><title>Status of the Open Source GPU Ecosystem @ OSSummit NA</title><link href="https://memcpy.io/status-of-the-open-source-gpu-ecosystem-ossummit-na.html" rel="alternate"></link><published>2018-08-31T00:00:00+02:00</published><updated>2018-08-31T00:00:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2018-08-31:/status-of-the-open-source-gpu-ecosystem-ossummit-na.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2018-08-31_ossummit.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2018-08-31/2018_gfx_status_ossummit_na.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2018-08-31/2018_gfx_status_ossummit_na.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://events.linuxfoundation.org/events/open-source-summit-north-america-2018/"&gt;OSSummit NA&lt;/a&gt;, the &lt;a href="https://www.linuxfoundation.org/"&gt;Linux Foundation&lt;/a&gt; for hosting a great event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="ossummit"></category><category term="open"></category><category term="source summit"></category><category term="linux"></category><category term="graphics"></category><category term="drivers"></category></entry><entry><title>Status of the Open Source Graphics Ecosystem @ OpenTechSummit</title><link href="https://memcpy.io/status-of-the-open-source-graphics-ecosystem-opentechsummit.html" rel="alternate"></link><published>2018-05-10T00:00:00+02:00</published><updated>2018-05-10T00:00:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2018-05-10:/status-of-the-open-source-graphics-ecosystem-opentechsummit.html</id><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2018-05-10_opentechsummit.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2018-05-10/2018_opentechsummit.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2018-05-10/2018_opentechsummit.odp"&gt;OTP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://opentechsummit.net/"&gt;OpenTechSummit&lt;/a&gt;, specifically &lt;a href="https://twitter.com/hpdang"&gt;@hpdang&lt;/a&gt; and &lt;a href="https://twitter.com/mariobehling"&gt;@mariobehling&lt;/a&gt;
for hosting a great event.&lt;/p&gt;</content><category term="talks"></category><category term="talks"></category><category term="slides"></category><category term="graphics"></category><category term="linux"></category><category term="drivers"></category><category term="open"></category><category term="tech"></category><category term="summit"></category><category term="opentechsummit"></category><category term="source"></category></entry><entry><title>Android: Enabling mainline graphics</title><link href="https://memcpy.io/android-enabling-mainline-graphics.html" rel="alternate"></link><published>2017-03-28T15:18:00+02:00</published><updated>2017-03-28T15:18:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2017-03-28:/android-enabling-mainline-graphics.html</id><summary type="html">&lt;p&gt;The  &lt;a href="https://source.android.com/devices/graphics/implement-hwc.html"&gt;HWC&lt;/a&gt; 
(Hardware Composer) API is used by SurfaceFlinger for compositing layers to the screen.
The HWC abstracts objects such as overlays and 2D blitters and helps offload some work
that would normally be done with OpenGL.
SurfaceFlinger on the other hand accepts buffers from multiple sources, composites them,
and sends them to the display.&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/2017-03-28_android_graphics_stack.png"&gt;&lt;img alt="Alt text" src="/images/2017-03-28_android_graphics_stack.png" title="Android Graphics Stack"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The above graphic depicts the traditional Android graphics stack.&lt;/p&gt;
&lt;p&gt;This is where drm_hwcomposer comes into play. Since the mainline kernel graphics stack
doesn't offer the HWC API, drm_hwcomposer is introduced to interface with the mainline
graphics stack through mesa and libdrm. Before this work drm_hwcomposer only offered the
HWC1 API.
Since Android 7.0 version 2 of the HWC API is used by SurfaceFlinger. HWC2 differs in a few
ways …&lt;/p&gt;</summary><content type="html">&lt;p&gt;The  &lt;a href="https://source.android.com/devices/graphics/implement-hwc.html"&gt;HWC&lt;/a&gt; 
(Hardware Composer) API is used by SurfaceFlinger for compositing layers to the screen.
The HWC abstracts objects such as overlays and 2D blitters and helps offload some work
that would normally be done with OpenGL.
SurfaceFlinger on the other hand accepts buffers from multiple sources, composites them,
and sends them to the display.&lt;/p&gt;
&lt;p&gt;&lt;a href="/images/2017-03-28_android_graphics_stack.png"&gt;&lt;img alt="Alt text" src="/images/2017-03-28_android_graphics_stack.png" title="Android Graphics Stack"&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;The above graphic depicts the traditional Android graphics stack.&lt;/p&gt;
&lt;p&gt;This is where drm_hwcomposer comes into play. Since the mainline kernel graphics stack
doesn't offer the HWC API, drm_hwcomposer is introduced to interface with the mainline
graphics stack through mesa and libdrm. Before this work drm_hwcomposer only offered the
HWC1 API.
Since Android 7.0 version 2 of the HWC API is used by SurfaceFlinger. HWC2 differs in a few
ways from the previous version, for example the semantics of fence support were changed and
the GPU can now be used as a fallback when compositing layers.&lt;/p&gt;
&lt;p&gt;Up until recently the mainline kernel lacked the fence primitive offered by Android
used in HWC1 and HWC2. But after my fellow Collaboran Gustavo Padovan's work on
&lt;a href="http://padovan.org/blog/2016/09/mainline-explicit-fencing-part-1/"&gt;adding fence support&lt;/a&gt;
to the mainline kernel was upstreamed in
&lt;a href="http://padovan.org/blog/2017/02/collabora-contributions-to-linux-kernel-4-10/"&gt;v4.10&lt;/a&gt;,
the mainline kernel now has fence support equivalent to that of Android.&lt;/p&gt;
&lt;p&gt;The new fence support enabled work on drm_hwcomposer to add HWC2 support.
And with it we are now able to boot Android on the db410c running the freedreno driver.
But in theory it should work on any mainline kernel graphics stack enabled GPU.&lt;/p&gt;
&lt;p&gt;Currently the work is being upstreamed to the
&lt;a href="https://chromium.googlesource.com/chromiumos/drm_hwcomposer/"&gt;ChromiumOS repo&lt;/a&gt;
which is the official upstream for drm_hwcomposer.&lt;/p&gt;
&lt;p&gt;A number of projects have seen contributions 8in order to enable this work:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;kernel - sync_file, in-fence and out-fence support added.&lt;/li&gt;
&lt;li&gt;libdrm - fence support added.&lt;/li&gt;
&lt;li&gt;mesa - support for passing fences added.&lt;/li&gt;
&lt;li&gt;intel-gpu-tools - sync and fence tests added.&lt;/li&gt;
&lt;li&gt;drm_hwcomposer - HWC2 and fence support added.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This drm_hwcomposer work is part of a long-standing collaboration between
Google's ChromeOS team and Collabora.&lt;/p&gt;
&lt;p&gt;A number of people have played an important role in this work:
Gustavo Padovan, Rob Clark, Sean Paul, Zach Reizner and Rob Herring.&lt;/p&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="aosp"></category><category term="android"></category><category term="aosp"></category><category term="graphics"></category><category term="drm"></category><category term="drm_hwcomposer"></category><category term="hwcomposer"></category><category term="hwc2"></category><category term="collabora"></category></entry><entry><title>XDC 2016</title><link href="https://memcpy.io/xdc-2016.html" rel="alternate"></link><published>2016-09-23T20:20:00+02:00</published><updated>2016-09-23T20:20:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2016-09-23:/xdc-2016.html</id><summary type="html">&lt;p&gt;&lt;img alt="Alt text" src="/images/2016-09-23_xdc_2016.jpg" title="XDC 2016"&gt;&lt;/p&gt;
&lt;p&gt;XDC 2016 was hosted in Helsinki at Haaga-Helia.
The full &lt;a href="https://www.x.org/wiki/Events/XDC2016/Program/"&gt;program&lt;/a&gt; was filmed and is archived &lt;a href="https://www.youtube.com/channel/UCXlH5v1PkEhjzLFTUTm_U7g/videos"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016-fast_ui_draw.pdf"&gt;Slides&lt;/a&gt;] FastUIDraw - High Performance 2D renderer for GPUs&lt;/h2&gt;
&lt;p&gt;Kevin Rogovin gave an excellent talk about FastUIDraw, which is a highly optimiser 2d renderer for GPUs.&lt;/p&gt;
&lt;p&gt;By agressively targetting GPUs only and limiting the feature set to what is required by a browser FastUIDraw performs &amp;gt;9.3x faster than Cairo-CPU and &amp;gt;4.8x times the previous GPU state of the art SKIA-GL.&lt;/p&gt;
&lt;p&gt;Hopefully FastUIDraw can be incorporated into upstream of ChromiumOS and Android.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016_2d_perf.pdf"&gt;Slides&lt;/a&gt;] 2D Performance&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://phd.mupuf.org/"&gt;Martin Perez&lt;/a&gt; gave a talk about 2D performance and power consumption of the Xserver.&lt;/p&gt;
&lt;p&gt;The xf86-video-intel driver showed quite mixed performance numbers of 1.51-32.6x times the CPU performance.
The FPS/Watt …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Alt text" src="/images/2016-09-23_xdc_2016.jpg" title="XDC 2016"&gt;&lt;/p&gt;
&lt;p&gt;XDC 2016 was hosted in Helsinki at Haaga-Helia.
The full &lt;a href="https://www.x.org/wiki/Events/XDC2016/Program/"&gt;program&lt;/a&gt; was filmed and is archived &lt;a href="https://www.youtube.com/channel/UCXlH5v1PkEhjzLFTUTm_U7g/videos"&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016-fast_ui_draw.pdf"&gt;Slides&lt;/a&gt;] FastUIDraw - High Performance 2D renderer for GPUs&lt;/h2&gt;
&lt;p&gt;Kevin Rogovin gave an excellent talk about FastUIDraw, which is a highly optimiser 2d renderer for GPUs.&lt;/p&gt;
&lt;p&gt;By agressively targetting GPUs only and limiting the feature set to what is required by a browser FastUIDraw performs &amp;gt;9.3x faster than Cairo-CPU and &amp;gt;4.8x times the previous GPU state of the art SKIA-GL.&lt;/p&gt;
&lt;p&gt;Hopefully FastUIDraw can be incorporated into upstream of ChromiumOS and Android.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016_2d_perf.pdf"&gt;Slides&lt;/a&gt;] 2D Performance&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://phd.mupuf.org/"&gt;Martin Perez&lt;/a&gt; gave a talk about 2D performance and power consumption of the Xserver.&lt;/p&gt;
&lt;p&gt;The xf86-video-intel driver showed quite mixed performance numbers of 1.51-32.6x times the CPU performance.
The FPS/Watt measurements showed 0.73-15.1x times the CPU efficiency.&lt;/p&gt;
&lt;p&gt;When looking at Cairo traces the power efficiency is actually lower using GPU accelaration than with CPU acceleration.
This is somewhat expected in that the Cairo workload is not very high throughput, so the overhead of doing 2D operations is relatively high compared to the actual work.&lt;/p&gt;
&lt;p&gt;Overall toolkits are moving away from letting the Xserver do 2D rendering, for reasons of portability and performance.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016-glvnd-status.pdf"&gt;Slides&lt;/a&gt;] libglvnd Status Update&lt;/h2&gt;
&lt;p&gt;Andy Ritger gave a talk about the current libglvnd status.
The goal of libglvnd is to allow different graphics libraries from potentially different vendors to coexist on a filesystem and in a process.
GLX/EGl/OpenGL/OpenGLES/GL are all supported by libglvnd.&lt;/p&gt;
&lt;p&gt;Currently mesa supports libglvnd for OpenGL and GLX, with EGL support being in the pipeline.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016-drm_hwcomposer.pdf"&gt;Slides&lt;/a&gt;] drm_hwcomposer&lt;/h2&gt;
&lt;p&gt;Sean Paul and Zach Reizner gave an exceptionally well timed talk about the Android &amp;amp;&amp;amp; Chromium drm_hwcomposer project.
drm_hwcomposer is an implementation of the hwcomposer (HWC) API ontop of the Linux DRM/KMS.&lt;/p&gt;
&lt;p&gt;The talk detailed the implications of HWC2 and explicit fencing.
A large part of the HWC1 implementation can be removed from drm_hwcomposer since it's made redundant by the fencing support in HWC2.
So, for example the worker threads (DrmCompositorWorker and FrameWorker) are no longer necessary and can be removed.&lt;/p&gt;
&lt;h2&gt;[&lt;a href="files/2016-09-23/xdc-2016-nouveau_update.pdf"&gt;Slides&lt;/a&gt;] Status update of Nouveau&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://hakzsam.wordpress.com/"&gt;Samuel Pitoiset&lt;/a&gt;, Karol Herbst, &lt;a href="https://twitter.com/kurtelborgpm"&gt;Pierre Moreau&lt;/a&gt; and &lt;a href="http://phd.mupuf.org/"&gt;Martin Perez&lt;/a&gt; gave a talk about what has happened in Nouveau land the last year.&lt;/p&gt;
&lt;p&gt;Hardware support is as always taking steps forward, with Fermi support is scheduled for Linux v4.9+.&lt;/p&gt;
&lt;p&gt;A call to arms for Nouveau compiler optimizations was issued by &lt;a href="mailto:martin.peres AT free DOT fr"&gt;Martin Perez&lt;/a&gt;.
There is a lot of low hanging fruit for optimizations is available, and the compiler is overall in a good shape.
So feel free to contact Martin or the Nouveau project if you are interested or curious.&lt;/p&gt;
&lt;p&gt;As of the Maxwell generation of GPUs the firmware needed now has to be signed, GM20x/GP100 firmware has been released, but support for loading firmware on Tegra has not been provided by NVidia.&lt;/p&gt;
&lt;p&gt;Martin made a rather clear point of needing to see some cooperation from NVidia in order for the Nouveau project to be able to make progress with new and upcoming NVidia hardware.&lt;/p&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Thanks to the X.Org Foundation and the board of directors for arranging XDC 2016.
This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="linux"></category><category term="linux"></category><category term="graphics"></category><category term="kernel"></category><category term="collabora"></category></entry></feed>