<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>memcpy.io - open source</title><link href="https://memcpy.io/" rel="alternate"></link><link href="https://memcpy.io/feeds/open-source.atom.xml" rel="self"></link><id>https://memcpy.io/</id><updated>2019-04-15T15:44:00+02:00</updated><entry><title>Running Android and Wayland on Embedded Devices</title><link href="https://memcpy.io/running-android-and-wayland-on-embedded-devices.html" rel="alternate"></link><published>2019-04-15T15:44:00+02:00</published><updated>2019-04-15T15:44:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-04-15:/running-android-and-wayland-on-embedded-devices.html</id><summary type="html">&lt;p&gt;&lt;a href="/running-android-next-to-wayland.html"&gt;A previous post&lt;/a&gt; introduced the &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/"&gt;SPURV&lt;/a&gt;
Android compatibility layer for Wayland based Linux environment.&lt;br&gt;
In this post we're going to dig into how you can run an Android application
on the very common i.MX6 based &lt;a href="https://boundarydevices.com/product/nitrogen6max/"&gt;Nitrogen6_MAX&lt;/a&gt;
board from &lt;a href="https://boundarydevices.com/"&gt;Boundary Devices&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Build SPURV for Nitrogen6_MAX&lt;/h2&gt;
&lt;h3&gt;Build Android&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir android; cd android
repo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r10
git clone https://gitlab.collabora.com/spurv/android_manifest.git .repo/local_manifests/
repo sync -j15
. build/envsetup.sh
lunch spurv-eng
make -j12
cd ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Build Linux Kernel&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://gitlab.collabora.com/zodiac/linux.git -b android-container
cd linux
sh ../android/device/freedesktop/spurv/build-kernel.sh
cd ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Create root filesystem&lt;/h3&gt;
&lt;p&gt;Just a kernel does not make an OS, so we're using Debian …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;a href="/running-android-next-to-wayland.html"&gt;A previous post&lt;/a&gt; introduced the &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/"&gt;SPURV&lt;/a&gt;
Android compatibility layer for Wayland based Linux environment.&lt;br&gt;
In this post we're going to dig into how you can run an Android application
on the very common i.MX6 based &lt;a href="https://boundarydevices.com/product/nitrogen6max/"&gt;Nitrogen6_MAX&lt;/a&gt;
board from &lt;a href="https://boundarydevices.com/"&gt;Boundary Devices&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Build SPURV for Nitrogen6_MAX&lt;/h2&gt;
&lt;h3&gt;Build Android&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir android; cd android
repo init -u https://android.googlesource.com/platform/manifest -b android-9.0.0_r10
git clone https://gitlab.collabora.com/spurv/android_manifest.git .repo/local_manifests/
repo sync -j15
. build/envsetup.sh
lunch spurv-eng
make -j12
cd ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Build Linux Kernel&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://gitlab.collabora.com/zodiac/linux.git -b android-container
cd linux
sh ../android/device/freedesktop/spurv/build-kernel.sh
cd ..
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Create root filesystem&lt;/h3&gt;
&lt;p&gt;Just a kernel does not make an OS, so we're using Debian as a base.&lt;br&gt;
The way we're going to create the root filesystem is using &lt;code&gt;debootstrap&lt;/code&gt;,
which is a tool for creating Debian based OS images.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt install debootstrap qemu-user-static
sudo debootstrap --include=systemd,weston,systemd-container,udev,sudo,openssh-server,iputils-ping,pulseaudio,psmisc,bc --arch armhf --variant minbase testing rootfs http://deb.debian.org/debian/
sudo chroot rootfs adduser aosp --ingroup sudo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you'd like to make further changes to the OS, you can simply chroot into the
root directory, and and &lt;code&gt;qemu-user-static&lt;/code&gt; will automatically run the ARM binaries
inside of QEMU, which makes the process of running binaries from foreign
architectures transparent.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo chroot rootfs
ls -la /
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Create &amp;amp; flash image&lt;/h3&gt;
&lt;p&gt;Now we're ready to integrate all of the above into one coeherent image.
This is where the Nitrogen6_MAX devboard targeting comes in.  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;android/device/freedesktop/spurv/create_image.sh -b /dev/mmcblk0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;The platform specific parts are contained in &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/uboot_nitrogen6qp-max.scr"&gt;uboot_nitrogen6qp-max.scr&lt;/a&gt;
and &lt;a href="https://gitlab.collabora.com/zodiac/device_freedesktop/blob/master/spurv/create_image.sh"&gt;create_image.sh&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Boot!&lt;/h2&gt;
&lt;p&gt;Pop the flashed SD-card into your device and restart it.
When it has booted, log in as &lt;code&gt;root/root&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In order to start Android, run one of these two commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# Launch just and Android application
/home/aosp/run.sh

# Launch some Wayland applications and an Android one
/home/aosp/run_demo.sh
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Starting the Android application might take a minute or two.&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;p&gt;A lot of different contributors enabled this work, both direcctly and indirectly.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Boundary Devices&lt;/li&gt;
&lt;li&gt;Pengutronix&lt;/li&gt;
&lt;li&gt;Zodiac&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="linux"></category><category term="open source"></category><category term="graphics"></category><category term="wayland"></category><category term="android"></category><category term="3d"></category><category term="acceleration"></category><category term="imx6"></category><category term="nitrogen6"></category></entry><entry><title>Running Android next to Wayland</title><link href="https://memcpy.io/running-android-next-to-wayland.html" rel="alternate"></link><published>2019-04-01T18:07:00+02:00</published><updated>2019-04-01T18:07:00+02:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-04-01:/running-android-next-to-wayland.html</id><summary type="html">&lt;p&gt;Running Android has some advantages compared to native Linux applications,
for example with regard to the availability of applications and application
developers.&lt;/p&gt;
&lt;p&gt;For current non-Android systems, this work enables a path forward to running
Android applications in the same graphical environment as traditional non-Android
applications are run.&lt;/p&gt;
&lt;div style#"text-align:center;"&gt;
&lt;iframe width="830" height="460" src="https://www.youtube.com/embed/594fIHWQSj4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2&gt;What is SPURV?&lt;/h2&gt;
&lt;p&gt;SPURV is our experimental containerized Android environment, and
this is a quick overview of what it is.&lt;/p&gt;
&lt;p&gt;It's aptly named after the &lt;a href="https://en.wikipedia.org/wiki/SPURV"&gt;first robotic fish&lt;/a&gt;
since a common Android naming scheme is fish-themed names. Much like its spiritual
ancestor Goldfish, the Android emulator.&lt;/p&gt;
&lt;h3&gt;Other Android Compatibility Layers&lt;/h3&gt;
&lt;p&gt;This means that Anbox which is LXC based, is different from SPURV in terms of
how hardware is accessed. The hardware access that Anbox provides in indirect,
and …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Running Android has some advantages compared to native Linux applications,
for example with regard to the availability of applications and application
developers.&lt;/p&gt;
&lt;p&gt;For current non-Android systems, this work enables a path forward to running
Android applications in the same graphical environment as traditional non-Android
applications are run.&lt;/p&gt;
&lt;div style#"text-align:center;"&gt;
&lt;iframe width="830" height="460" src="https://www.youtube.com/embed/594fIHWQSj4" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;h2&gt;What is SPURV?&lt;/h2&gt;
&lt;p&gt;SPURV is our experimental containerized Android environment, and
this is a quick overview of what it is.&lt;/p&gt;
&lt;p&gt;It's aptly named after the &lt;a href="https://en.wikipedia.org/wiki/SPURV"&gt;first robotic fish&lt;/a&gt;
since a common Android naming scheme is fish-themed names. Much like its spiritual
ancestor Goldfish, the Android emulator.&lt;/p&gt;
&lt;h3&gt;Other Android Compatibility Layers&lt;/h3&gt;
&lt;p&gt;This means that Anbox which is LXC based, is different from SPURV in terms of
how hardware is accessed. The hardware access that Anbox provides in indirect,
and through the Qemu Pipes functionality, which is something it adopted from
the Android (goldfish) emulator.&lt;/p&gt;
&lt;p&gt;Shashlik and Genimobile are Android on Linux integration layers both based on
Qemu, which means even better security properties than Anbox and certainly SPURV,
but at the cost of an even larger performance penalty.&lt;/p&gt;
&lt;h3&gt;Direct Hardware Access&lt;/h3&gt;
&lt;p&gt;SPURV is different from other Linux desktop integrations for Android
since it offers direct hardware access to the Android application.
This is a choice we made for performance reasons. But has drawbacks, especially
when it comes to security.&lt;br&gt;
Using direct hardware access does however grant us increased GPU and CPU
performance, which is important since we're targeting embedded platforms
which can have very limited resources.&lt;/p&gt;
&lt;h2&gt;Components&lt;/h2&gt;
&lt;p&gt;SPURV consists of a few different parts, all living in the same &lt;a href="https://gitlab.collabora.com/spurv/"&gt;project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;&lt;img alt="An overview of the SPURV stack" src="/images/2019_spurv.svg"&gt;&lt;/p&gt;
&lt;h3&gt;Android target device&lt;/h3&gt;
&lt;p&gt;This component integrates SPURV into Android, and it does so by using the
&lt;code&gt;device&lt;/code&gt; infrastructure that the Android codebase provides.&lt;/p&gt;
&lt;p&gt;Devices are normally used to customize an Android build to the
specific needs of a given hardware platform, like a new smartphone
SOC. In the case of SPURV, we're targeting being run inside of
a &lt;code&gt;systemd-nspawn&lt;/code&gt; container.&lt;/p&gt;
&lt;h3&gt;SPURV Audio&lt;/h3&gt;
&lt;p&gt;This component bridges the Android Audio Hardware Abtraction Layer (HAL) to
the host PulseAudio stack.&lt;/p&gt;
&lt;h3&gt;SPURV HWComposer&lt;/h3&gt;
&lt;p&gt;Integrates Android windows into Wayland. It does so by implementing a HWC-to-Wayland bridge.&lt;/p&gt;
&lt;p&gt;HWC is the Android API for implementing display &amp;amp; buffer management, and what it essentially
does in interpret all of the different display buffers that Android applications produce,
and organizes them into one cohesive Desktop.&lt;/p&gt;
&lt;p&gt;This protocol is conceptually not unlike the Wayland protocol, which allows for the HWC to
be translated into Wayland. This is essentially what the SPURV HWComposer does.&lt;/p&gt;
&lt;p&gt;Additionally it deals with input, like touch screen events and passes them along from Wayland
to Android, this however is unrelated to the HWC API.&lt;/p&gt;
&lt;h3&gt;How does it work?&lt;/h3&gt;
&lt;p&gt;The SPURV Android target device behaves as a faux Android device, and tailors
the Android build to our requirements.&lt;/p&gt;
&lt;p&gt;Functions SPURV performs:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Customizes defaults.&lt;/li&gt;
&lt;li&gt;Configures network.&lt;/li&gt;
&lt;li&gt;Enables an audio bridge from Android to PulseAudio.&lt;/li&gt;
&lt;li&gt;Enables a graphics bridge from Android to Wayland.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;How can I use it?&lt;/h2&gt;
&lt;p&gt;Full build instructions as can be found on our &lt;a href="https://gitlab.collabora.com/spurv/device_freedesktop/blob/master/spurv/README.md"&gt;GitLab&lt;/a&gt; for the &lt;a href="https://gitlab.collabora.com/spurv"&gt;SPURV project&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;An overview of setting up:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Fetch Android (AOSP) and the Linux kernel,&lt;/li&gt;
&lt;li&gt;Integrate SPURV into Android,&lt;/li&gt;
&lt;li&gt;Build Android &amp;amp; Linux Kernel,&lt;/li&gt;
&lt;li&gt;Build a debootstrap based root filesystem, and&lt;/li&gt;
&lt;li&gt;Flash Kernel, Android and root filesystem to the device of your choice.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;What comes next?&lt;/h2&gt;
&lt;p&gt;The next few steps will be adding support for more hardware platforms
in our build scripts, but also optimizing the experience.&lt;/p&gt;
&lt;p&gt;In no particular order, this is what we would like to look at next:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bring-up on the i.MX8M with the etnaviv graphics driver.&lt;/li&gt;
&lt;li&gt;Slimming things down so it takes less time to start an app and consumes less
   RAM for the case where the goal is to just to run a single app.&lt;/li&gt;
&lt;li&gt;Bring-up on x86 with Ubuntu, publishing runtime binaries.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Caveats&lt;/h2&gt;
&lt;p&gt;The way SPURV is implemented means that a full OS is being run in a container,
which has implications both positive and negative.&lt;/p&gt;
&lt;p&gt;One of the positive effects is increased isolation of Android applications,
which means improved security and privacy for potentially untrusted applications.&lt;/p&gt;
&lt;p&gt;Additionally, this approach allows for Android applications to be run next to
Wayland based applications in a desktop environment.&lt;/p&gt;
&lt;p&gt;The downsides relate to hardware access and performance. All hardware access
that is needed by Android has to be passed into the container.
Besides manually having to configure such access using &lt;code&gt;systemd-nspawn&lt;/code&gt;,
there are also performance costs associated with running a container.
One part of this is the static cost of having to load an entire OS on top
of the base OS, but there are also additional runtime performance penalties
for applications in the container.&lt;/p&gt;
&lt;h2&gt;Acknowledgements&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Pengutronix&lt;/li&gt;
&lt;li&gt;Zodiac&lt;/li&gt;
&lt;li&gt;Boundary Devices&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="linux"></category><category term="open source"></category><category term="graphics"></category><category term="wayland"></category><category term="android"></category><category term="3d"></category><category term="acceleration"></category></entry><entry><title>An Overview of the Panfrost driver</title><link href="https://memcpy.io/an-overview-of-the-panfrost-driver.html" rel="alternate"></link><published>2019-03-13T16:25:00+01:00</published><updated>2019-03-13T16:25:00+01:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-03-13:/an-overview-of-the-panfrost-driver.html</id><summary type="html">&lt;p&gt;&lt;img alt="Arm driver timeline" src="/images/2019-03-13_arm_driver_timeline.png"&gt;&lt;/p&gt;
&lt;p&gt;The process of reverse engineering Arm GPUs has been going on for a long time,
starting with &lt;a href="https://github.com/libv"&gt;Luc Verhaegens&lt;/a&gt; work on the low-end Mali 2/3/400 series of GPUs based
on the Arm Utgard family of GPUs.&lt;br&gt;
This driver has recently seen a lot new attention and is itself progressing quickly,
which means it will likely be accepted into the kernel soon.&lt;br&gt;
A piece of trivia is that this GPU architecture was what Arm received when they
purchased the Norwegian GPU IP vendor Falanx Microsystems.&lt;/p&gt;
&lt;p&gt;The Mali T and G-series of GPUs are based on the Midgard and Bifrost architectures
respectively, both of which are quite different from the 2/3/400 series.
However the T and G-series are somewhat similar at least when …&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Arm driver timeline" src="/images/2019-03-13_arm_driver_timeline.png"&gt;&lt;/p&gt;
&lt;p&gt;The process of reverse engineering Arm GPUs has been going on for a long time,
starting with &lt;a href="https://github.com/libv"&gt;Luc Verhaegens&lt;/a&gt; work on the low-end Mali 2/3/400 series of GPUs based
on the Arm Utgard family of GPUs.&lt;br&gt;
This driver has recently seen a lot new attention and is itself progressing quickly,
which means it will likely be accepted into the kernel soon.&lt;br&gt;
A piece of trivia is that this GPU architecture was what Arm received when they
purchased the Norwegian GPU IP vendor Falanx Microsystems.&lt;/p&gt;
&lt;p&gt;The Mali T and G-series of GPUs are based on the Midgard and Bifrost architectures
respectively, both of which are quite different from the 2/3/400 series.
However the T and G-series are somewhat similar at least when it comes to the
way a driver can be built for them. This is why the Panfrost driver is aiming
to support both architectures with one driver.&lt;/p&gt;
&lt;div style="text-align:center;"&gt;
&lt;iframe src="https://drive.google.com/file/d/1GqOHbaI2ZcBkYnWBpMXy-LgCyLgzdLRg/preview" width="640" height="480"&gt;&lt;/iframe&gt;
&lt;/div&gt;

&lt;p&gt;At &lt;a href="https://www.embedded-world.de/en"&gt;Embedded World 2019&lt;/a&gt; Collabora demoed the
Panfrost driver running kmscube (pictured to the right).
The singleboard computer used was a &lt;a href="https://rockpi.org"&gt;Radxa Rock Pi 4&lt;/a&gt;,
which was generously sent to us by &lt;a href="https://twitter.com/hipboi_"&gt;Tom Cubie&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Panfrost currently runs simple 3D applications like kmscube, the Wayland based
Weston desktop and even more complex 3D benchmarks like glmark2.&lt;/p&gt;
&lt;p&gt;This is still a new driver and it is in heavy development currently.&lt;/p&gt;
&lt;h2&gt;Current status&lt;/h2&gt;
&lt;p&gt;There are two semi-parallel parts under development currently; the new kernel
driver and the Mesa userspace driver.&lt;/p&gt;
&lt;p&gt;&lt;img alt="Panfrost demo" src="/images/2019-03-13_panfrost.svg"&gt;&lt;/p&gt;
&lt;p&gt;The new kernel driver is intended to replace the Open Source driver that Arm
provides for its Mali GPUs (mali_kbase). Up until recently the Mesa Panfrost driver
has been used with a shim between the Arm kernel driver and the userspace driver.
While the Arm kernel driver exists, it cannot be accepted into the upstream Linux
kernel project for multiple reasons, but most importantly it doesn't expose the
DRM API that userspace expects of modern GPU drivers in the kernel.&lt;/p&gt;
&lt;p&gt;As for the Panfrost Mesa driver, this driver is under heavy development
and is seeing fixes, improvements to the compiler and new features added at a
rapid pace.
This driver is being built on top of the common Gallium driver framework in
Mesa, which means that it will be relatively easy to move features from other
drivers to the Panfrost driver.&lt;br&gt;
Additionally the Panfrost driver uses the NIR intermediate representation (IR) for
its compiler, which is the most common and most modern IR that Mesa implements.
This again means that new and upcoming features like OpenCL for example, will
be portable from the other Gallium/NIR drivers to Panfrost.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;These drivers are community drivers, but have been spearheaded by
&lt;a href="https://rosenzweig.io/blog/"&gt;Alyssa Rosenzweig&lt;/a&gt;,
&lt;a href="https://twitter.com/_Lyude"&gt;Lyude Paul&lt;/a&gt;,
&lt;a href="https://github.com/cwabbott0"&gt;Connor Abott&lt;/a&gt;,
&lt;a href="https://github.com/robherring"&gt;Rob Herring&lt;/a&gt; and
Collabora's very own &lt;a href="https://blog.tomeuvizoso.net"&gt;Tomeu Vizoso&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would also like to thank &lt;a href="https://twitter.com/hipboi_"&gt;Tom Cubie&lt;/a&gt; for sending
out Rock Pi 4 boards to not just me, but the wider Panfrost development community.&lt;/p&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;</content><category term="linux"></category><category term="open source"></category><category term="gpu"></category><category term="driver"></category><category term="arm"></category><category term="mali"></category><category term="panfrost"></category></entry><entry><title>Status of the Embedded GPU Space @ Embedded World</title><link href="https://memcpy.io/status-of-the-embedded-gpu-space-embedded-world.html" rel="alternate"></link><published>2019-02-27T00:00:00+01:00</published><updated>2019-02-27T00:00:00+01:00</updated><author><name>Robert Foss</name></author><id>tag:memcpy.io,2019-02-27:/status-of-the-embedded-gpu-space-embedded-world.html</id><summary type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2019-02-27_embedded_world.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://www.embedded-world.de/en"&gt;Embedded World&lt;/a&gt; for hosting a great event.&lt;/p&gt;</summary><content type="html">&lt;p&gt;&lt;img alt="Intro slide" src="/images/2019-02-27_embedded_world.png"&gt;&lt;/p&gt;
&lt;h2&gt;Downloads&lt;/h2&gt;
&lt;p&gt;If you're curious about the slides, you can download the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.pdf"&gt;PDF&lt;/a&gt; or
the &lt;a href="/files/2019-02-27/2019_embedded-gfx_embedded-world.odp"&gt;ODP&lt;/a&gt;.&lt;/p&gt;
&lt;h2&gt;Thanks&lt;/h2&gt;
&lt;p&gt;This post has been a part of work undertaken by my employer &lt;a href="http://www.collabora.com"&gt;Collabora&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I would like to thank the wonderful organizers of &lt;a href="https://www.embedded-world.de/en"&gt;Embedded World&lt;/a&gt; for hosting a great event.&lt;/p&gt;</content><category term="talks"></category><category term="slides"></category><category term="embedded"></category><category term="world"></category><category term="graphics"></category><category term="open source"></category><category term="drivers"></category><category term="linux"></category></entry></feed>