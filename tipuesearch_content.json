{"pages":[{"url":"http://memcpy.io/about-me.html","text":"Software engineer specialized in embedded, open source and linux. Hey! I'm Robert Foss. I'm a software engineer, and memcpy is my software contracting business. When I'm not busy writing software for work, I typically do it for fun. I'm a contributor of a few open source projects, NodeMCU , I2P and of course all the projects I've spawned on GitHub . When I'm not writing software, I dabble in hardware design and manufacturing. Most of these project can be seen on this blog. Some are close to almost at the finished product stage, while some are a bit more hacked together. Venturing into the land of electronics has also grown an interest in manufacturing and design for manufacturing. Feel free to contact me at contact@robertfoss.se .","tags":"pages","title":"About me"},{"url":"http://memcpy.io/contracting.html","text":"memcpy offers software engineering services in the embedded, open source and linux space. Previous embedded projects have been bring-up for stm32f4 based platforms, bring up for nrf51422 based platforms and drivers/captive portals for the esp8266. Open source related projects have recently been in the IoT/esp8266/ NodeMCU space. If you're interested in getting a quote, availibility information or just discussing a project, feel free to contact me at contact@robertfoss.se .","tags":"pages","title":"Contracting"},{"url":"http://memcpy.io/running-weston-on-a-raspbian.html","text":"Progress in the VC4 graphics camp and the Wayland camp now enables us to run Weston on top of the drm backend for VC4 platforms. Previously software acceleration using pixman was needed, but this is no longer the case. Additionally the rpi backend for weston is now being removed since it has been obsoleted by the improved drm layer. Let's explore running hardware accelerated Weston on the Raspberry Pi. Building Linux kernel A comprehensive guide for building a recent Linux kernel for Raspberry Pi boards has been written by the Raspberry Pi foundation and is available here . As of this writing the guide helps you build a v4.4 kernel which is good enough for our purposes. Set up alternative install location These build instructions are based on the Wayland instructions from freedesktop.org, but altered to target VC4 and Raspbian. You probably don't want to install experimental builds of software among the usual software of your operating system, so let's define a prefix for where to install our builds. # Change WLD to any location you like export WLD=/opt/local export LD_LIBRARY_PATH= $ WLD /lib export PKG_CONFIG_PATH= $ WLD /lib/pkgconfig/: $ WLD /share/pkgconfig/ export PATH= $ WLD /bin: $ PATH export ACLOCAL_PATH= $ WLD /share/aclocal export ACLOCAL=\"aclocal -I $ ACLOCAL_PATH \" # Needed by autotools mkdir -p $ WLD /share/aclocal Installing dependencies Start by installing the build dependencies of mesa, weston and wayland. # Enable source packages sudo sed -e \"s/#\\sdeb-src/deb-src/g\" -i /etc/apt/sources.list sudo apt update The above step can alternatively be completed using the GUI of your package manager, by enabling source packages. # Install build dependencies of mesa sudo apt-get build-dep mesa # Install build dependencies of wayland/weston sudo apt-get install \\ libevdev libevdev-dev \\ libwacom libwacom-dev \\ libxkbcommon libxkbcommon-dev Building Mesa Configure and compile mesa with vc4, wayland and EGL support. git clone git://anongit.freedesktop.org/mesa/mesa cd mesa ./autogen.sh --prefix= $ WLD \\ --enable-gles2 \\ --with-egl-platforms=x11,wayland,drm \\ --enable-gbm --enable-shared-glapi \\ --with-gallium-drivers=vc4 \\ --disable-va \\ --disable-vdpau \\ --disable-xvmc \\ --disable-omx make -j4 && make install Building Weston and dependencies Weston and Wayland have a number of dependencies that also need to be fetched and built. Wayland Weston is a Wayland compositor, so we're going to have to build Wayland. git clone git://anongit.freedesktop.org/wayland/wayland cd wayland ./autogen.sh --prefix= $ WLD make -j4 && make install cd .. git clone git://anongit.freedesktop.org/wayland/wayland-protocols cd wayland-protocols ./autogen.sh --prefix= $ WLD make install cd .. libinput libinput is dependency of wasten, handles input devices like keyboards, touchpads and mice. git clone git://anongit.freedesktop.org/wayland/libinput cd libinput ./autogen.sh --prefix= $ WLD make -j4 && make install cd .. Weston Finally we've built all of the dependencies of Weston and can now build it. git clone git://anongit.freedesktop.org/wayland/weston cd weston ./autogen.sh --prefix= $ WLD \\ --disable-libunwind make -j4 && sudo make install cd .. Running Weston That wasn't so bad, it took a little while, but now we're ready to start Weston. # Make sure that $DISPLAY is unset. unset DISPLAY # And that $XDG_RUNTIME_DIR has been set and created. if test -z \" ${ XDG_RUNTIME_DIR } \"; then export XDG_RUNTIME_DIR=/tmp/ ${ UID } -runtime-dir if ! test -d \" ${ XDG_RUNTIME_DIR } \"; then mkdir \" ${ XDG_RUNTIME_DIR } \" chmod 0700 \" ${ XDG_RUNTIME_DIR } \" fi fi # Run weston: weston Try weston applications Now that we're running weston, let's try some applications. They're located in the top level directory of weston. weston-terminal weston-flower weston-gears weston-smoke weston-image weston-view weston-resizor weston-eventdemo When you've started all of your favorite applications you can grab a screenshot by pressing Super + s , which will save wayland-screenshot.png in your home directory.","tags":"wayland","title":"Running Weston on a Raspbian"},{"url":"http://memcpy.io/coverpage-template.html","text":"Coverpage is a single-page landing page built to showcase an idea or a product. To allow interested parties to get notified of updates, the template has mailchimp subscription integration. A live version of the site can be found at coverpage.memcpy.io . Sources git clone https://github.com/robertfoss/coverpage.git GitHub hosting This template was built with the explicit intention of having it be hosted at GitHub in a gh-pages branch. Therefore it includes a Makefile for pushing copy of the current design to a gh-pages branch.","tags":"coverpage","title":"Coverpage template"},{"url":"http://memcpy.io/esp8266-apa102-bulb.html","text":"The product of this project is a WiFi connected LED bulb. Every LED on this bulb is individually programmable over the WiFi, by simply sending UDP packets to the bulb. Software and hardware sources git clone https://github.com/robertfoss/esp8266_apa102_bulb.git This project consists of 3 parts: the software running on the led bulb, the software running on some host computer and the hardware. Firmware The firmare is based on the NodeMCU firwmare for the ESP8266. It's running the APA102 LED driver and the enduser setup module, which I've written about previously . Additionally it's running 3 lua scripts that deal with different aspects. There's init.lua which makes sure we're connected to a WiFi. udp_listener.lua receives UDP packets and then sends forwards that data to the APA102 strips. And lastly udb_broadcast.lua which periodically broadcasts a heartbeat for this LED bulb to signal that it is alive and well. Host application The current (as of the publish date of this post) incarnation of the host application listens for bulbs that are alive on the hosts network. If a bulb is found is will be added to the list of bulbs to be animated. All animations are simple and sinusoidal and only use the time a bulb has been 'alive' as an input for the animation. Hardware The hardware is based around the ESP8266 WiFi IC and the APA102 SPI LED IC. The flavor of ESP8266 used in this project is the ESP12-F module, since it the latest module available with the integrated antenna form factor. APA102 was chosen instead of the much more common WS2812B chip, since it uses a SPI like protocol which isn't timing sensitive and also does not require external capacitors at next to each LED. v3.1 Schematic v2 3D Model Assembled v2 hardware","tags":"ESP8266","title":"ESP8266 APA102 Bulb"},{"url":"http://memcpy.io/ws2812-led-matrix.html","text":"The LED Matrix is constructed out of a WS2812B 8x8 panel, a 3D printed case, an ESP8266, a LiPo battery and some software. Code git clone https://github.com/robertfoss/esp8266_ws2812_matrix.git The software is divided into two parts. The receiving end is run on the ESP8266 that has been flashed with NodeMCU and is a simple lua script that receives UDP packets and forwards them to the excellent WS2812 module created by the the equally excellent Konrad Beckmann . The second part is run on a host pc. It's a simple python script that generates a framebuffer from a sinusoidal animation and transmits it over UDP to the IP of the ESP8266. This relies on the host pc being able to connect to the ESP8266. Ideally they're on the same LAN to minimise UDP packets being lost or delayed, which causes the animation to lag or skip. This part was also written by Konrad Beckmann as part of a larger fancier animation, but repurposed here to be used as a proof of concept. 3D Model The 3D model was created using google sketchup. The case is a made out of 2 parts. A front and a lid. The front has grooves that fit the WS2812 LEDs and make sure that the matrix is firmly stuck in place but also make sure that the light from the LEDs is diffused the proper amount. Bill of materials 18$ WS2812B 8x8 Matrix 2$ ESP8266 ESP-01 1$ AMS1117-3.3 Voltage regulator 4$ LiPo 3.7V 300mAh - A higher capacity battery is better as long as it fits inside of the case. $3 LiPo USB Charger $6 Battery connector cable - Only a few will be needed. A thing to be aware of is the fact that all orders from AliExpress will take at least 30 days to arrive to your door. Sometimes more. Hardware construction You'll have to excuse the lack of a proper schematic, but this has been a fairly organic project. The connectors of for the battery (B_VCC and B_GND), the WS2812 matrix (LED_VCC, LED_GND and LED_DATA), the ESP8266 (ESP_3V3, ESP_CH_PD, ESP_GND, ESP_GPIO2) and the AMS1117-3.3V (LDO_VCC, LDO_GND and LDO_3V3) B_VCC + LED_VCC + LDO_VCC B_GND + LED_GND + LDO_GND + ESP_GND LDO_3V3 + ESP_3V3 + ESP_CH_PD LED_DATA + ESP_GPIO2 Issues and TODOs The AMS1117-3.3 is not ideal. The voltage drop is too high. Ideally it should be replaced with a Step-UP/DOWN converter. When the battery is running low the ESP8266 is the first part to fail. It does so while there is quite a lot of power left in the LiPo. This setup does not work at all without a WiFi or a host computer feeding it animations. Nothing is preventing is from working without a connection, but the connection is one of the most interesting aspects of the project.","tags":"ESP8266","title":"WS2812 LED Matrix"},{"url":"http://memcpy.io/ws2812-welding-goggles.html","text":"The goggles were built using an AtTiny85 module and a WS2812B strip and some bits and bobs that were laying around. A more complete BOM can be found below. Code git clone https://github.com/robertfoss/digispark_ws2812_waves.git The animation is built ontop of the excellent light_ws2812 library. It supports the AtTiny85 better than other competing libraries like FastLED. The animation is built around an non-float sin function and a HSV function that generates the actual colors. Video Your browser does not support the video tag. Bill of materials 6€ Weldorado STROOF DIN4 Welding Goggles 2$ Digispark 23$ WS2812B Strip 144 LEDs/m - Only about a 5th of the length needed. 2x$4 LiPo 3.7V 300mAh $3 LiPo USB Charger $6 Battery connector cable - Only a few will be needed. $4 Rainbow cable - Any cable would do, but this keeps the cables bunched. $3 Black 20mm veclro - Only a small part will be needed for attaching to batteries and the inside of the goggles. Things to keep in mind when ordering these parts are that Weldorado won't accept an order for a single pair of goggles. You will have to order 3-4 pairs. And additionally pay a decent chunk of change for the shipping. So the more goggles you can find a use for the cheaper it will get. They are very nice looking though. Especially the rubber ones. A thing to note about the goggles is that the headstrap that ships with them is failry useless and probably should be replaced. Another thing to be aware of is the fact that all orders from AliExpress will take at least 30 days to arrive to your door. Sometimes more. Hardware construction You'll have to excuse the lack of a proper schematic, but this has been a fairly organic project. The connectors of for the batteries (B_VCC and B_GND), both WS2812B strips (LED_VCC, LED_GND and LED_DATA) and the digispark (DIG_5V, DIG_GND and DIG_PIN0) are soldered as follows: B_VCC + LED_VCC + DIG_5V B_GND + LED_GND + DIG_GND LED_DATA + DIG_PIN0 Issues and TODOs There is complete lack of an off-switch, and plugging and unplugging the battery is slightly messy. Especially in the unlit situations where these goggles would be fun to wear. The brightness is static and can only be changed by reflashing the AtTiny85. A potentiometer or button that toggles between different intensities (and possibly an OFF of sleep mode) would be very useful. The current head strap is made out of leather and is slightly hard to put on yourself. The glass is black which does make it very hard to see when it's dark. Since that is when the goggles are most fun to use, maybe the glass should be replaced.","tags":"WS2812","title":"WS2812 Welding Goggles"},{"url":"http://memcpy.io/user-friendly-setup-of-esp8266-gadgets.html","text":"The ESP8266 lacks a simple end-user compatible way to be configured with the login details of the local WiFi. Running the ESP8266 in a 'captive portal' mode where every http request is hijacked and replaced with form allows the end user to submit the credentials of the local WiFi hotspot by simply connecting to an ESP8266 hosted access point. esp8266_nodemcu_wifi_setup is designed to provide a simple interface for users to configure their ESP8266/NodeMCU based devices through. Start ESP. Connect to the \"SetupGadget\" WiFi through your internet enabled thing of choice. Submit credentials of your local WiFi. The ESP reboots and connects to your local WiFi. What is this magic! How could a mere mortal like me summon features like this?! Let me tell you.. By default DNS is not announced in the DHCP offer message, because a DNS server does not ship with NodeMCU. In order to announce that the ESP8266 is running a DNS server, NodeMCU has to be recompiled to support that. A guide to building NodeMCU can be found here . Thanks to the wonderful work of Andy Reischles on Captive Portal , a lua implementation of a domain hijacking DNS server exists. Which will allow an ESP8266 to redirect all traffic to itself. Detailed guide In dhcpserver.h, #define USE_DNS 1 Build NodeMCU. Flash NodeMCU. Upload all .lua files and index.html. Reboot ESP. What you need to do After a user has connected throught the portal and sucessfully configured the the ESP8266 with the credentials of the local WiFi, something lua service should be started so that the ESP8266 actually does something. I would suggest adding something like this to init.lua: dofile(\"init_connected.lua\") Where init_connected.lua is where your script resides.","tags":"ESP8266","title":"User friendly setup of ESP8266 gadgets"},{"url":"http://memcpy.io/building-nodemcu-for-the-esp8266.html","text":"This is a simple step-by-step guide to building and flashing NodeMCU for the ESP8266. Build ESP8266 SDK sudo apt-get install make unrar autoconf automake libtool gcc g++ gperf flex bison texinfo gawk ncurses-dev libexpat-dev python sed cd /opt git clone https://github.com/pfalcon/esp-open-sdk.git cd esp-open-sdk git submodule sync git submodule update make export PATH=/opt/esp-open-sdk/xtensa-lx106-elf/bin: $ PATH Build NodeMCU git clone https://github.com/nodemcu/nodemcu-firmware.git cd nodemcu-firmware # Switch to dev branch, since it's the most up to date git checkout --track origin/dev # Make INTEGER version, since it uses less memory/space make EXTRA_CCFLAGS=\"-DLUA_NUMBER_INTEGRAL\" Flash NodeMCU COMPORT=/dev/ttyUSB0 make flash Modifying NodeMCU to fit your needs app/include/user_modules.h Contains a list of which modules to include in the build. ... #define LUA_USE_MODULES_NODE #define LUA_USE_MODULES_FILE #define LUA_USE_MODULES_GPIO #define LUA_USE_MODULES_WIFI #define LUA_USE_MODULES_NET ... app/include/user_config.h Contains NodeMCU developer options, but could be of use. ... #define DEVELOP_VERSION #define NODE_ERROR ...","tags":"ESP8266","title":"Building NodeMCU for the ESP8266"}]}